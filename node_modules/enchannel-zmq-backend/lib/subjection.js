'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepFreeze = deepFreeze;
exports.formConnectionString = formConnectionString;
exports.createSubscriber = createSubscriber;
exports.createObservable = createObservable;
exports.createSubject = createSubject;
exports.createSocket = createSocket;

var _rxjs = require('@reactivex/rxjs');

var _jmp = require('jmp');

var jmp = _interopRequireWildcard(_jmp);

var _constants = require('./constants');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Recursive Object.freeze, does not handle functions since Jupyter messages
 * are plain JSON.
 * @param {Object} obj object to deeply freeze
 * @return {Object} the immutable object
 */
function deepFreeze(obj) {
  // Freeze properties before freezing self
  Object.getOwnPropertyNames(obj).forEach(function (name) {
    var prop = obj[name];
    if ((typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) === 'object' && prop !== null && !Object.isFrozen(prop)) {
      deepFreeze(prop);
    }
  });
  // Freeze self
  return Object.freeze(obj);
}

/**
 * Takes a Jupyter spec connection info object and channel and returns the
 * string for a channel. Abstracts away tcp and ipc(?) connection string
 * formatting
 * @param {Object} config  Jupyter connection information
 * @param {string} channel Jupyter channel ("iopub", "shell", "control", "stdin")
 * @return {string} The connection string
 */
function formConnectionString(config, channel) {
  var portDelimiter = config.transport === 'tcp' ? ':' : '-';
  var port = config[channel + '_port'];
  if (!port) {
    throw new Error('Port not found for channel "' + channel + '"');
  }
  return config.transport + '://' + config.ip + portDelimiter + port;
}

/**
 * A RxJS wrapper around jmp sockets, that takes care of sending messages and
 * cleans up after itself
 * @param {jmp.Socket} socket the jmp/zmq socket connection to a kernel channel
 * @return {Rx.Subscriber} a subscriber that allows sending messages on next()
 *                         and closes the underlying socket on complete()
 */
function createSubscriber(socket) {
  return _rxjs.Subscriber.create(function (messageObject) {
    socket.send(new jmp.Message(messageObject));
  }, function (err) {
    // We don't expect to send errors to the kernel
    console.error(err);
  }, function () {
    // tear it down, tear it *all* down
    socket.removeAllListeners();
    socket.close();
  });
}

/**
 * Creates observable that behaves according to enchannel spec
 * @param {jmp.Socket} socket the jmp/zmq socket connection to a kernel channel
 * @return {Rx.Observable} an Observable that publishes kernel channel messages
 */
function createObservable(socket) {
  return _rxjs.Observable.fromEvent(socket, 'message').map(function (msg) {
    // Conform to same message format as notebook websockets
    // See https://github.com/n-riesco/jmp/issues/10
    delete msg.idents;
    delete msg.signatureOK;
    delete msg.blobs;
    // Deep freeze the message
    deepFreeze(msg);
    return msg;
  }).publish().refCount();
}

/**
 * Helper function for creating a subject from a socket
 * @param {jmp.Socket} socket the jmp/zmq socket connection to a kernel channel
 * @return {Rx.Subject} subject for sending and receiving messages to kernels
 */
function createSubject(socket) {
  var subj = _rxjs.Subject.create(createSubscriber(socket), createObservable(socket));
  return subj;
}

/**
 * Creates a socket for the given channel with ZMQ channel type given a config
 * @param {string} channel Jupyter channel ("iopub", "shell", "control", "stdin")
 * @param {string} identity UUID
 * @param {Object} config  Jupyter connection information
 * @return {jmp.Socket} The new Jupyter ZMQ socket
 */
function createSocket(channel, identity, config) {
  var zmqType = _constants.ZMQType.frontend[channel];
  var scheme = config.signature_scheme.slice('hmac-'.length);
  var socket = new jmp.Socket(zmqType, scheme, config.key);
  socket.identity = identity;
  socket.connect(formConnectionString(config, channel));
  return socket;
}
//# sourceMappingURL=subjection.js.map