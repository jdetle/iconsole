{"version":3,"sources":["../src/subjection.js"],"names":[],"mappings":";;;;;;;QAagB;QAoBA;QAgBA;QAkBA;QAqBA;QAaA;;;;;;IApGJ;;;;;;;;;;;;AAYL,SAAS,UAAT,CAAoB,GAApB,EAAyB;;AAE9B,SAAO,mBAAP,CAA2B,GAA3B,EAAgC,OAAhC,CAAwC,gBAAQ;AAC9C,QAAM,OAAO,IAAI,IAAJ,CAAP,CADwC;AAE9C,QAAG,QAAO,mDAAP,KAAgB,QAAhB,IAA4B,SAAS,IAAT,IAAiB,CAAC,OAAO,QAAP,CAAgB,IAAhB,CAAD,EAAwB;AACtE,iBAAW,IAAX,EADsE;KAAxE;GAFsC,CAAxC;;AAF8B,SASvB,OAAO,MAAP,CAAc,GAAd,CAAP,CAT8B;CAAzB;;;;;;;;;;AAoBA,SAAS,oBAAT,CAA8B,MAA9B,EAAsC,OAAtC,EAA+C;AACpD,MAAM,gBAAgB,OAAO,SAAP,KAAqB,KAArB,GAA6B,GAA7B,GAAmC,GAAnC,CAD8B;AAEpD,MAAM,OAAO,OAAO,UAAU,OAAV,CAAd,CAF8C;AAGpD,MAAI,CAAE,IAAF,EAAQ;AACV,UAAM,IAAI,KAAJ,kCAAyC,aAAzC,CAAN,CADU;GAAZ;AAGA,SAAU,OAAO,SAAP,WAAsB,OAAO,EAAP,GAAY,gBAAgB,IAA5D,CANoD;CAA/C;;;;;;;;;AAgBA,SAAS,gBAAT,CAA0B,MAA1B,EAAkC;AACvC,SAAO,iBAAW,MAAX,CAAkB,yBAAiB;AACxC,WAAO,IAAP,CAAY,IAAI,IAAI,OAAJ,CAAY,aAAhB,CAAZ,EADwC;GAAjB,EAEtB,eAAO;;AAER,YAAQ,KAAR,CAAc,GAAd,EAFQ;GAAP,EAGA,YAAM;;AAEP,WAAO,kBAAP,GAFO;AAGP,WAAO,KAAP,GAHO;GAAN,CALH,CADuC;CAAlC;;;;;;;AAkBA,SAAS,gBAAT,CAA0B,MAA1B,EAAkC;AACvC,SAAO,iBAAW,SAAX,CAAqB,MAArB,EAA6B,SAA7B,EACW,GADX,CACe,eAAO;;;AAGV,WAAO,IAAI,MAAJ,CAHG;AAIV,WAAO,IAAI,WAAJ,CAJG;AAKV,WAAO,IAAI,KAAJ;;AALG,cAOV,CAAW,GAAX,EAPU;AAQV,WAAO,GAAP,CARU;GAAP,CADf,CAWW,OAXX,GAYW,QAZX,EAAP,CADuC;CAAlC;;;;;;;AAqBA,SAAS,aAAT,CAAuB,MAAvB,EAA+B;AACpC,MAAM,OAAO,cAAQ,MAAR,CAAe,iBAAiB,MAAjB,CAAf,EACe,iBAAiB,MAAjB,CADf,CAAP,CAD8B;AAGpC,SAAO,IAAP,CAHoC;CAA/B;;;;;;;;;AAaA,SAAS,YAAT,CAAsB,OAAtB,EAA+B,QAA/B,EAAyC,MAAzC,EAAiD;AACtD,MAAM,UAAU,mBAAQ,QAAR,CAAiB,OAAjB,CAAV,CADgD;AAEtD,MAAM,SAAS,OAAO,gBAAP,CAAwB,KAAxB,CAA8B,QAAQ,MAAR,CAAvC,CAFgD;AAGtD,MAAM,SAAS,IAAI,IAAI,MAAJ,CAAW,OAAf,EAAwB,MAAxB,EAAgC,OAAO,GAAP,CAAzC,CAHgD;AAItD,SAAO,QAAP,GAAkB,QAAlB,CAJsD;AAKtD,SAAO,OAAP,CAAe,qBAAqB,MAArB,EAA6B,OAA7B,CAAf,EALsD;AAMtD,SAAO,MAAP,CANsD;CAAjD","file":"subjection.js","sourcesContent":["import { Subscriber, Observable, Subject } from '@reactivex/rxjs';\nimport * as jmp from 'jmp';\n\nimport {\n  ZMQType,\n} from './constants';\n\n/**\n * Recursive Object.freeze, does not handle functions since Jupyter messages\n * are plain JSON.\n * @param {Object} obj object to deeply freeze\n * @return {Object} the immutable object\n */\nexport function deepFreeze(obj) {\n  // Freeze properties before freezing self\n  Object.getOwnPropertyNames(obj).forEach(name => {\n    const prop = obj[name];\n    if(typeof prop === 'object' && prop !== null && !Object.isFrozen(prop)) {\n      deepFreeze(prop);\n    }\n  });\n  // Freeze self\n  return Object.freeze(obj);\n}\n\n/**\n * Takes a Jupyter spec connection info object and channel and returns the\n * string for a channel. Abstracts away tcp and ipc(?) connection string\n * formatting\n * @param {Object} config  Jupyter connection information\n * @param {string} channel Jupyter channel (\"iopub\", \"shell\", \"control\", \"stdin\")\n * @return {string} The connection string\n */\nexport function formConnectionString(config, channel) {\n  const portDelimiter = config.transport === 'tcp' ? ':' : '-';\n  const port = config[channel + '_port'];\n  if (! port) {\n    throw new Error(`Port not found for channel \"${channel}\"`);\n  }\n  return `${config.transport}://${config.ip}${portDelimiter}${port}`;\n}\n\n/**\n * A RxJS wrapper around jmp sockets, that takes care of sending messages and\n * cleans up after itself\n * @param {jmp.Socket} socket the jmp/zmq socket connection to a kernel channel\n * @return {Rx.Subscriber} a subscriber that allows sending messages on next()\n *                         and closes the underlying socket on complete()\n */\nexport function createSubscriber(socket) {\n  return Subscriber.create(messageObject => {\n    socket.send(new jmp.Message(messageObject));\n  }, err => {\n    // We don't expect to send errors to the kernel\n    console.error(err);\n  }, () => {\n    // tear it down, tear it *all* down\n    socket.removeAllListeners();\n    socket.close();\n  });\n}\n\n/**\n * Creates observable that behaves according to enchannel spec\n * @param {jmp.Socket} socket the jmp/zmq socket connection to a kernel channel\n * @return {Rx.Observable} an Observable that publishes kernel channel messages\n */\nexport function createObservable(socket) {\n  return Observable.fromEvent(socket, 'message')\n                   .map(msg => {\n                     // Conform to same message format as notebook websockets\n                     // See https://github.com/n-riesco/jmp/issues/10\n                     delete msg.idents;\n                     delete msg.signatureOK;\n                     delete msg.blobs;\n                     // Deep freeze the message\n                     deepFreeze(msg);\n                     return msg;\n                   })\n                   .publish()\n                   .refCount();\n}\n\n/**\n * Helper function for creating a subject from a socket\n * @param {jmp.Socket} socket the jmp/zmq socket connection to a kernel channel\n * @return {Rx.Subject} subject for sending and receiving messages to kernels\n */\nexport function createSubject(socket) {\n  const subj = Subject.create(createSubscriber(socket),\n                              createObservable(socket));\n  return subj;\n}\n\n/**\n * Creates a socket for the given channel with ZMQ channel type given a config\n * @param {string} channel Jupyter channel (\"iopub\", \"shell\", \"control\", \"stdin\")\n * @param {string} identity UUID\n * @param {Object} config  Jupyter connection information\n * @return {jmp.Socket} The new Jupyter ZMQ socket\n */\nexport function createSocket(channel, identity, config) {\n  const zmqType = ZMQType.frontend[channel];\n  const scheme = config.signature_scheme.slice('hmac-'.length);\n  const socket = new jmp.Socket(zmqType, scheme, config.key);\n  socket.identity = identity;\n  socket.connect(formConnectionString(config, channel));\n  return socket;\n}\n"]}